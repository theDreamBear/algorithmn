针对排列组合的问题想要找到所有子状态，会用到回溯法， 而使用的回溯法，一般有两种基本实现

### 选择/不选择的回溯算法更优的问题类型：
> 不考虑顺序的时候
1. **子集问题**：如求解一个集合的所有子集。这类问题每个元素都有选择或不选择两种状态。
2. **组合问题**：寻找满足特定条件的元素组合，如求解组合总和问题。在这种问题中，我们关心的是组合本身，而不是元素的顺序。
3. **部分排列问题**：需要考虑某些元素是否出现在排列中，但不关心整体顺序。
4. **决策树问题**：如二叉树路径问题，每一步都是一个二元选择（是或否）。

#### 基本实现
```cpp
    void dfs(int i) {
        // 判断当前状态是否满足

        // i 到了边界
        if (i > n) {
            return;
        }
        // 不选择
        dfs(i + 1)
        // 回溯
        push(i)
        dfs(i + 1)
        pop(i);
    }
```


### For循环里面的回溯算法更优的问题类型：
> 需要考虑顺序的时候
1. **排列问题**：需要求解所有可能的元素排列方式，如全排列问题。因为需要考虑元素的顺序，for循环能有效处理元素间的顺序关系。
2. **棋盘问题**：如N皇后问题，需要在棋盘的每一行或列放置一个元素。For循环适用于遍历棋盘的每一行或列。
3. **组合问题的变体**：当组合问题中元素的顺序也重要时，例如在字符串中寻找所有可能的字母组合。
4. **图相关问题**：例如寻找图中的所有可能路径，for循环可以有效地遍历图的节点。

#### 基本实现
```cpp
void dfs(int i) {
    // 判断当前状态是否满足

    // i 到了边界
    if (i > n) {
        return;
    }
    // 遍历所有子树
    for (int i = pos; i < n; ++i) {
        // 关于顺序方面的减枝

        // 回溯
        push(i)
        dfs(i + 1);
        // 回溯
        pop(i)
    }
}
```

#### 验证for循环的完备性
0 不选择对应位置
1 对应选择当前位置

假设当前有4个元素需要选择

第0 层  0000
第一层  1xxx 01xx 001x 0001
0000 + 0001 = 000x
001x + 000x = 00xx
01xx + 00xx = 0xxx
1xxx + 0xxx = all 我们可以得到所有的状态


### 总结：
选择/不选择的回溯算法在处理元素是/否加入解集的决策时更为直观和简洁，适合子集、组合等问题。而For循环里面的回溯算法在处理需要考虑元素顺序的问题时更为合适，例如排列或特定顺序的组合问题。在实际编程实践中，根据问题特性和个人习惯选择适合的方法非常重要。

## 针对排列问题

### 全排列
#### 基于选择
```cpp
    void dfs(vector<int>& marked) {
        // 判断是否满足 + 边界判断

        // 判断是否走到头了

        for (int i = 0; i < n; i++) {
            if (!marked[i]) {
                marked[i] = 1;
                dfs(marked);
                marked[i] = 0;
            }
        }
    }
```
#### 基于交换
```cpp
    void dfs(int pos) {
        // 判断是否满足 + 边界判断
        for (int i = pos; i < nums.size(); i++) {
            // 使用交换来代替marked，保证[pos, n) 的都是没有选择过的
            swap(nums[i], nums[pos]);
            dfs(pos + 1);
            swap(nums[i], nums[pos]);
        }
    }
```