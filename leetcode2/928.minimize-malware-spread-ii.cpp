/*
 * @lc app=leetcode.cn id=928 lang=cpp
 * @lcpr version=30122
 *
 * [928] 尽量减少恶意软件的传播 II
 */


// @lcpr-template-start
using namespace std;
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <deque>
#include <functional>
#include <iostream>
#include <list>
#include <queue>
#include <stack>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
// @lcpr-template-end
// @lc code=start
class Solution {
public:
    class NodeRemover {
     public:
        vector<vector<int>>& graph;
        int v;
        unordered_set<int> from, to;

        NodeRemover(vector<vector<int>>& graph, int v): graph(graph), v(v) {
            // 删除v
            for (int i = 0; i < graph[v].size(); i++) {
                if (graph[v][i]) {
                    from.insert(i);
                    graph[v][i] = 0;
                }
            }
            for (int i = 0; i < graph.size(); i++) {
                if (graph[i][v]) {
                    to.insert(i);
                    graph[i][v] = 0;
                }
            }
        }

        ~NodeRemover() {
            for (auto x : from) {
                graph[v][x] = 1;
            }
            for (auto x : from) {
                graph[x][v] = 1;
            }
        }
    };

    int minMalwareSpread1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int ans = n, M = n;
        for (auto v : initial) {
            // 物理移除
            NodeRemover nr(graph, v);
            int t = 0;
            vector<int> marked(n);
            function<void(int)> dfs = [&](int v) {
                if (marked[v]) {
                    return;
                }
                ++t;
                marked[v] = 1;
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !marked[w]) {
                        dfs(w);
                    }
                }
            };
            for (auto x : initial) {
                dfs(x);
            }
            if (t < M || t == M and ans > v) {
                ans = v;
                M = t;
            }
        }
        return ans;
    }

    int minMalwareSpread2(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int ans = n, M = n;
        for (auto v : initial) {
            int t = 0;
            vector<int> marked(n);
            // 标记移除
            marked[v] = 1;
            function<void(int)> dfs = [&](int v) {
                if (marked[v]) {
                    return;
                }
                ++t;
                marked[v] = 1;
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !marked[w]) {
                        dfs(w);
                    }
                }
            };
            for (auto x : initial) {
                dfs(x);
            }
            if (t < M || t == M and ans > v) {
                ans = v;
                M = t;
            }
        }
        return ans;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int ans = n, M = n;
        for (auto v : initial) {
            int t = 0;
            vector<int> marked(n);
            // 标记移除
            marked[v] = 1;
            function<void(int)> dfs = [&](int v) {
                if (marked[v]) {
                    return;
                }
                ++t;
                marked[v] = 1;
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !marked[w]) {
                        dfs(w);
                    }
                }
            };
            for (auto x : initial) {
                dfs(x);
            }
            if (t < M || t == M and ans > v) {
                ans = v;
                M = t;
            }
        }
        return ans;
    }
};
// @lc code=end



/*
// @lcpr case=start
// [[1,1,0],[1,1,0],[0,0,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,0],[1,1,1],[0,1,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]\n[0,1]\n
// @lcpr case=end

 */

