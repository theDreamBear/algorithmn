/*
 * @lc app=leetcode.cn id=924 lang=cpp
 * @lcpr version=30122
 *
 * [924] 尽量减少恶意软件的传播
 */


 // @lcpr-template-start
using namespace std;
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <deque>
#include <functional>
#include <iostream>
#include <list>
#include <queue>
#include <stack>
#include <tuple>
#include <unordered_map>
#include <set>
#include <utility>
#include <vector>
#include <numeric>
// @lcpr-template-end
// @lc code=start
class Solution {
public:
    int minMalwareSpread_bfs(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            queue<int> q;
            vector<int> visited(n);
            int ct = 0;
            for (int j = 0; j < initial.size(); j++) {
                if (i == j) {
                    continue;
                }
                q.push(initial[j]);
                visited[initial[j]] = 1;
                ++ct;
            }
            while (!q.empty()) {
                auto node = q.front();
                q.pop();
                for (int vi = 0; vi < graph[node].size(); vi++) {
                    if (graph[node][vi] == 1 and !visited[vi]) {
                        q.push(vi);
                        visited[vi] = 1;
                        ++ct;
                    }
                }
            }
            if (M > ct || (M == ct and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    int minMalwareSpread_dfs1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            vector<int> visited(n);
            int ct = 0;
            function<void(int)> dfs = [&](int v) {
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !visited[w]) {
                        ++ct;
                        visited[w] = 1;
                        dfs(w);
                    }
                }
                };
            for (int j = 0; j < initial.size(); j++) {
                if (i == j || visited[initial[j]]) {
                    continue;
                }
                // 递归前标记
                visited[initial[j]] = 1;
                ++ct;
                dfs(initial[j]);
            }
            if (ct < M || (ct == M and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    int minMalwareSpread_dfs2(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            vector<int> visited(n);
            int ct = 0;
            function<void(int)> dfs = [&](int v) {
                if (visited[v]) {
                    return;
                }
                // 递归中标记
                ++ct;
                visited[v] = 1;
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !visited[w]) {
                        dfs(w);
                    }
                }
                };
            for (int j = 0; j < initial.size(); j++) {
                if (i == j || visited[initial[j]]) {
                    continue;
                }
                dfs(initial[j]);
            }
            if (ct < M || (ct == M and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    class UF {
    public:
        int n;
        vector<int> p, ct;
        int sub = 0;

        UF(int n) : n(n), p(n), ct(n) {
            iota(p.begin(), p.end(), 0);
            fill(ct.begin(), ct.end(), 1);
        }

        int find(int v) {
            return p[v] == v ? v : p[v] = find(p[v]);
        }

        void merge(int v, int w) {
            int pv = find(v);
            int pw = find(w);
            if (pv == pw) {
                return;
            }
            p[pv] = pw;
            ct[pw] += ct[pv];
        }

        int Sub(int v) {
            return ct[find(v)];
        }
    };

    int minMalwareSpread_uf(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        UF uf(n);
        for (int i = 0; i < graph.size(); i++) {
            for (int j = 0; j < graph[i].size(); j++) {
                if (graph[i][j]) {
                    uf.merge(i, j);
                }
            }
        }
        for (int i = 0; i < initial.size(); i++) {
            unordered_set<int> seen;
            int ct = 0;
            for (int j = 0; j < initial.size(); j++) {
                if (i == j) {
                    continue;
                }
                int pv = uf.find(initial[j]);
                if (seen.count(pv)) {
                    continue;
                }
                seen.insert(pv);
                ct += uf.Sub(pv);
            }
            if (ct < M || (ct == M and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        // 结果
        int ans =  -1;
        // 最大的单个污染连通分量的大小
        int m = 0;
        set<int> initial_set(initial.begin(), initial.end());
        vector<int> marked(n);
        for (auto v : initial) {
            if (marked[v]) {
                continue;
            }
            int t = 0, el = -1;
            function<void(int)> dfs = [&](int v) {
                if (marked[v]) {
                    return;
                }
                marked[v] = 1;
                ++t;
                if (initial_set.count(v)) {
                    el = el == -1 ? v : -2;
                }
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !marked[w]) {
                        dfs(w);
                    }
                }
            };
            dfs(v);
            if (el >= 0 and (t > m || t == m and ans > el)) {
                m = t;
                ans = el;
            }
        }
        return ans < 0 ? *initial_set.begin() : ans;
    }
};
// @lc code=end



/*
// @lcpr case=start
// [[1,1,0],[1,1,0],[0,0,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,0,0],[0,1,0],[0,0,1]]\n[0,2]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,1],[1,1,1],[1,1,1]]\n[1,2]\n
// @lcpr case=end

 */

