/*
 * @lc app=leetcode.cn id=924 lang=cpp
 * @lcpr version=30122
 *
 * [924] 尽量减少恶意软件的传播
 */


// @lcpr-template-start
using namespace std;
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <deque>
#include <functional>
#include <iostream>
#include <list>
#include <queue>
#include <stack>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <numeric>
// @lcpr-template-end
// @lc code=start
class Solution {
public:
    int minMalwareSpread_bfs(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            queue<int> q;
            vector<int> visited(n);
            int ct = 0;
            for (int j = 0; j < initial.size(); j++) {
                if (i == j) {
                    continue;
                }
                q.push(initial[j]);
                visited[initial[j]] = 1;
                ++ct;
            }
            while (!q.empty()) {
                auto node = q.front();
                q.pop();
                for (int vi = 0; vi < graph[node].size(); vi++) {
                    if (graph[node][vi] == 1 and !visited[vi]) {
                        q.push(vi);
                        visited[vi] = 1;
                        ++ct;
                    }
                }
            }
            if (M > ct || (M == ct and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    int minMalwareSpread_dfs1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            vector<int> visited(n);
            int ct = 0;
            function<void(int)> dfs = [&](int v) {
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !visited[w]) {
                        ++ct;
                        visited[w] = 1;
                        dfs(w);
                    }
                }
            };
            for (int j = 0; j < initial.size(); j++) {
                if (i == j || visited[initial[j]]) {
                    continue;
                }
                // 递归前标记
                visited[initial[j]] = 1;
                ++ct;
                dfs(initial[j]);
            }
            if (ct < M || (ct == M and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            vector<int> visited(n);
            int ct = 0;
            function<void(int)> dfs = [&](int v) {
                if (visited[v]) {
                    return;
                }
                // 递归中标记
                ++ct;
                visited[v] = 1;
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w] and !visited[w]) {
                        dfs(w);
                    }
                }
            };
            for (int j = 0; j < initial.size(); j++) {
                if (i == j || visited[initial[j]]) {
                    continue;
                }
                dfs(initial[j]);
            }
            if (ct < M || (ct == M and ans > initial[i])) {
                M = ct;
                ans = initial[i];
            }
        }
        return ans;
    }

    class UF {
     public:
        int n;
        vector<int> p;
        unordered_set<int> bad;
        int sub = 0;

        UF(int n): n(n), p(n) {
            iota(p.begin(), p.end(), 0);
        }

        int find(int v) {
            return p[v] == v ? v : p[v] = find(p[v]);
        }

        void merge(int v, int w) {
            bad.insert(v);
            bad.insert(w);
            int pv = find(v);
            int pw = find(w);
            if (pv == pw) {
                return;
            }
            p[pv] = pw;
        }

        int Sub() {
            return bad.size();
        }
    };
    int minMalwareSpread_bad(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int M = n;
        int ans = n - 1;
        for (int i = 0; i < initial.size(); i++) {
            UF uf(n);
            for (int j = 0; j < initial.size(); j++) {
                if (i == j) {
                    continue;
                }
                int v = initial[j];
                for (int w = 0; w < graph[v].size(); w++) {
                    if (graph[v][w]) {
                        uf.merge(v, w);
                        // 需要继续传递
                        // ？
                    }
                }
            }
            if (uf.Sub() < M || (uf.Sub() == M and ans > initial[i])) {
                M = uf.Sub();
                ans = initial[i];
            }
        }
        return ans;
    }
};
// @lc code=end



/*
// @lcpr case=start
// [[1,1,0],[1,1,0],[0,0,1]]\n[0,1]\n
// @lcpr case=end

// @lcpr case=start
// [[1,0,0],[0,1,0],[0,0,1]]\n[0,2]\n
// @lcpr case=end

// @lcpr case=start
// [[1,1,1],[1,1,1],[1,1,1]]\n[1,2]\n
// @lcpr case=end

 */

